# -*- coding: utf-8 -*-
"""Muhammad Roshaan Idrees_56177_AI_Lab07

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EZtAHGMnaAI9PZp8WI3mVOV-_4LYQlnx

**Muhammad Roshaan Idrees**

---


**56177**

# **1: Use different string/s.**
"""

import random

# Number of individuals in each generation
POPULATION_SIZE = 100

# Valid genes
GENES = '''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890'''

# Target string to be generated
TARGET = "Muhammad Roshaan Idrees"

class Individual(object):
    '''
    class representing individual in population
    '''
    def __init__(self, chromosome):
        self.chromosome = chromosome
        self.fitness = self.cal_fitness()

    @classmethod
    def mutated_genes(self):
        '''
        create random genes for mutation
        '''
        global GENES
        return random.choice(GENES)

    def mutate(self):
        '''
        create random genes for mutation
        '''
        global GENES
        index = random.randrange(0, len(self.chromosome))
        self.chromosome = self.chromosome[:index] + self.mutated_genes() + self.chromosome[index+1:]
        self.fitness = self.cal_fitness()

    def cal_fitness(self):
        return sum(1 for expected, actual in zip(TARGET, self.chromosome) if expected != actual)

# Driver code
def main():
    global POPULATION_SIZE
    # current generation
    generation = 1
    found = False
    population = []
    # create initial population
    for _ in range(POPULATION_SIZE):
        genome = ''.join(random.choice(GENES) for _ in range(len(TARGET)))
        population.append(Individual(genome))
    while not found:
        # sort the population in increasing order of fitness score
        population = sorted(population, key=lambda x: x.fitness)
        # if the individual having lowest fitness score ie. 0 then we know that we have reached to the target
        if population[0].fitness <= 0:
            found = True
            break
        # Otherwise generate new offsprings for new generation
        new_generation = []
        # Perform Elitism, that mean 10% of fittest population
        # goes to the next generation
        s = int((10*POPULATION_SIZE)/100)
        new_generation.extend(population[:s])
        # From 50% of fittest population, Individuals
        # will mate to produce offspring
        s = int((90*POPULATION_SIZE)/100)
        for _ in range(s):
            parent1 = random.choice(population[:50])
            parent2 = random.choice(population[:50])
            child_chromosome = []
            for i in range(len(parent1.chromosome)):
                gene = parent1.chromosome[i] if random.random() < 0.5 else parent2.chromosome[i]
                child_chromosome.append(gene)
            child = Individual(''.join(child_chromosome))
            child.mutate()
            new_generation.append(child)
        population = new_generation
        # sort the population in increasing order of fitness score
        population = sorted(population, key=lambda x: x.fitness)
        print("Generation: {}\tString: {}\tFitness: {}".format(generation, "" .join(population[0].chromosome), population[0].fitness))
        generation += 1
        if generation >= 1000:
            break

if __name__ == '__main__':
    main()

"""#**2: Update below listed parameter of genetic algorithm and analyze effects.**
#**o POPULATION_SIZE**

#**o Mutation and Crossover Operators**

#**o prob [probability]**
"""

import random

# Number of individuals in each generation
# Updated from 100 to 150

POPULATION_SIZE = 150

# Valid genes
GENES = '''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890'''

# Target string to be generated
TARGET = "Muhammad Roshaan Idrees"

class Individual(object):
    '''
    class representing individual in population
    '''
    def __init__(self, chromosome):
        self.chromosome = chromosome
        self.fitness = self.cal_fitness()

    @classmethod
    def mutated_genes(self):

        '''
        create random genes for mutation
        '''

        global GENES
        return random.choice(GENES)

    # Updated mutation probability to 0.3

    def mutate(self, mutation_prob=0.3):

        '''
        create random genes for mutation
        '''

        global GENES
        if random.random() < mutation_prob:
            index = random.randrange(0, len(self.chromosome))
            self.chromosome = self.chromosome[:index] + self.mutated_genes() + self.chromosome[index+1:]
            self.fitness = self.cal_fitness()

    def cal_fitness(self):
        return sum(1 for expected, actual in zip(TARGET, self.chromosome) if expected != actual)

# Driver code
def main():
    global POPULATION_SIZE

    # current generation

    generation = 1
    found = False
    population = []

    # create initial population

    for _ in range(POPULATION_SIZE):
        genome = ''.join(random.choice(GENES) for _ in range(len(TARGET)))
        population.append(Individual(genome))
    while not found:

        # sort the population in increasing order of fitness score

        population = sorted(population, key=lambda x: x.fitness)

        # if the individual having lowest fitness score ie. 0 then we know that we have reached to the target

        if population[0].fitness <= 0:
            found = True
            break

        # Otherwise generate new offsprings for new generation

        new_generation = []

        # Perform Elitism, that mean 10% of fittest population
        # goes to the next generation

        s = int((10*POPULATION_SIZE)/100)
        new_generation.extend(population[:s])

        # From 50% of fittest population, Individuals
        # will mate to produce offspring

        s = int((90*POPULATION_SIZE)/100)
        for _ in range(s):
            parent1 = random.choice(population[:50])
            parent2 = random.choice(population[:50])
            child_chromosome = []
            for i in range(len(parent1.chromosome)):

              # Updated crossover probability to 0.7

                gene = parent1.chromosome[i] if random.random() < 0.7 else parent2.chromosome[i]
                child_chromosome.append(gene)
            child = Individual(''.join(child_chromosome))
            # Updated mutation probability
            child.mutate(mutation_prob=0.3)
            new_generation.append(child)
        population = new_generation

        # sort the population in increasing order of fitness score

        population = sorted(population, key=lambda x: x.fitness)
        print("Generation: {}\tString: {}\tFitness: {}".format(generation, "".join(population[0].chromosome), population[0].fitness))
        generation += 1
        if generation >= 1000:
            break

if __name__ == '__main__':
    main()

"""# **3: Implement N-Queens problem.**"""

import random

# Size of the board
N = 8

# Number of individuals in each generation

POPULATION_SIZE = 100

class Individual(object):

    '''
    class representing individual in population
    '''

    def __init__(self, chromosome):
        self.chromosome = chromosome
        self.fitness = self.cal_fitness()

    @classmethod
    def mutated_genes(self):

        '''
        create random position for mutation
        '''

        return random.randint(0, N-1)

    def mutate(self):

        '''
        create random position for mutation
        '''

        index = random.randrange(0, len(self.chromosome))
        self.chromosome[index] = self.mutated_genes()
        self.fitness = self.cal_fitness()

    def cal_fitness(self):
        attacks = 0
        for i in range(N):
            for j in range(i + 1, N):
                if self.chromosome[i] == self.chromosome[j] or abs(self.chromosome[i] - self.chromosome[j]) == abs(i - j):
                    attacks += 1
        return N * (N - 1) // 2 - attacks  # Maximize non-attacking pairs

# Driver code
def main():
    global POPULATION_SIZE

    # current generation

    generation = 1
    found = False
    population = []

    # create initial population

    for _ in range(POPULATION_SIZE):
        genome = [random.randint(0, N-1) for _ in range(N)]
        population.append(Individual(genome))
    while not found:

        # sort the population in increasing order of fitness score

        population = sorted(population, key=lambda x: x.fitness, reverse=True)

        # if the individual having highest fitness score ie. N*(N-1)/2 then we know that we have reached to the target

        if population[0].fitness == N * (N - 1) // 2:
            found = True
            break

        # Otherwise generate new offsprings for new generation

        new_generation = []

        # Perform Elitism, that mean 10% of fittest population
        # goes to the next generation

        s = int((10 * POPULATION_SIZE) / 100)
        new_generation.extend(population[:s])

        # From 50% of fittest population, Individuals
        # will mate to produce offspring

        s = int((90 * POPULATION_SIZE) / 100)
        for _ in range(s):
            parent1 = random.choice(population[:50])
            parent2 = random.choice(population[:50])
            child_chromosome = []
            for i in range(N):
                gene = parent1.chromosome[i] if random.random() < 0.5 else parent2.chromosome[i]
                child_chromosome.append(gene)
            child = Individual(child_chromosome)
            child.mutate()
            new_generation.append(child)
        population = new_generation

        # sort the population in increasing order of fitness score

        population = sorted(population, key=lambda x: x.fitness, reverse=True)
        print("Generation: {}\tSolution: {}\tFitness: {}".format(generation, population[0].chromosome, population[0].fitness))
        generation += 1
        if generation >= 1000:
            break

if __name__ == '__main__':
    main()